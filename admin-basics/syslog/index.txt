== Что происходит в системе ==

Человеку, отвечающему за работоспособность системы, очень важно всегда
отчётливо представлять происходящие в ней события. Теоретически, никакое
происшествие не должно ускользнуть от его внимания. Однако компьютерные системы
настолько сложны, что отслеживать _все_ события в них -- выше человеческих
возможностей. Для того чтобы довести поток служебной информации до разумного
объёма, её надо _просеять_ (выкинуть незначащие данные), _классифицировать_
(разделить на несколько групп сообразно тематике) и _журнализировать_
(сохранить в доступном виде для дальнейшего анализа).

В Linux эта задача решается с помощью механизма _централизованной
журнализации_, который реализован системной службой syslogd. Все
части системы (включая ядро и системные службы) рапортуют syslogd о
происходящих в них событиях. В этот рапорт включается имя службы, _категория_
(facility) и _важность_ (priority) произошедшего события. Служба, сообразно
настройкам, классифицирует все эти рапорты в несколько выходных потоков.
Классификация и отсев данных всякого выходного потока происходит так: для
каждой категории событий определяется _наименьшая_ важность, которой событие
должно обладать, чтобы попасть в этот выходной поток. Например, легко
определить поток «ошибки», в который будут попадать только _важные_ рапорты
любых категорий или поток «безопасность», в который будут попадать _все_
рапорты категории «безопасность» и те рапорты других категорий, важность
которых заставляет подозревать угрозу безопасности системы (например, рапорт
категории «daemon» об аварийном завершении работы системной службы).

_Главное_ место хранения уже классифицированного syslogd потока событий --
_системный журнал_ (т. н. log-файл). Системный журнал -- _текстовый файл_,
содержащий рапорты _одного_ потока. Обычно syslogd хранит системные журналы в
каталоге `/var/log` и его подкаталогах. Именно в системные журналы, прежде
всего в `/var/log/messages`, `/var/log/maillog` и `/var/log/dmesg`, необходимо
заглядывать администратору, который хочет знать, что происходит в системе.
Поток рапортов о важных событиях syslogd направляет и на _системную консоль_ --
выделенное терминальное устройство. В ALT Linux роль системной консоли
выполняет 12-я _виртуальная консоль_, доступная по сочетанию клавиш *Alt+F12*
или *Alt+Ctrl+F12*. Стоит заметить, что некоторые службы (например, WWW-сервер
apache) _самостоятельно_, в обход syslogd, ведут журнализацию своих событий,
поэтому информацию о количестве и местоположении их журналов можно почерпнуть
из их файлов настроек (обычно, журналы хранятся в `/var/log`).

Новые рапорты, поступающие в системный журнал, наиболее актуальны, а
предыдущие, по мере их устаревания, эту актуальность утрачивают. Если самые
старые данные в журнале не удалять, файловая система рано или поздно окажется
переполненной. В Linux организован механизм _устаревания журналов_, которым
занимается служба logrotate. Запускаясь раз в день, logrotate проверяет, какие
из файлов следует признать устаревшими. Файл объявляется устаревшим один раз в
определённый промежуток времени (например, раз в неделю) или при достижении им
определённого размера.

Процедура устаревания такова. Для каждого журнала, как, например, для
`/var/log/syslog/alert`, logrotate держит в том же каталоге _очередь устаревших
копий_ -- файлы с именами от `alert.1.bz2` (предыдущая копия) до `alert.5.bz2`
(самая старая копия). Очередь `alert` в нашем примере состоит из пяти
упакованных с помощью `bzip2` файлов. В момент устаревания `alert.4.bz2`
переименовывается в `alert.5.bz2` (старые данные теряются), копия с номером 3
превращается в четвёртую, вторая -- в третью, первая во вторую. Наконец, сам
журнал упаковывается и переименовывается в `alert.1.bz2`, а на его месте
заводится новый -- пустой. Таким образом, администратор всегда имеет доступ к
_свежему_ журналу и к нескольким его копиям за определённое время.

Некоторые файлы в `/var/log` -- не текстовые, они являются неполноценными
журналами и представляют собой «свалку событий» для служб авторизации и
учёта. Текстовую информацию о входе пользователей в систему и выходе оттуда
можно получить по команде `last`, а узнать о тех, кто в данный момент
пользуется системой помогут команды `w` и `who`.

Множество важной информации может дать анализ _загруженности_ системы --
сведения о процессорном времени и потреблении оперативной памяти (`ps`, `top`,
`vmstat`), сведения об использовании дискового пространства (`du`, `df`,
`lsof`) и сведения о работе сетевых устройств (`netstat`).
