Когда компьютеры назывались «электронно-вычислительными машинами», они были
размерами в среднем с кухонный гарнитур и занимались почти исключительно
вычислениями. Ввод и вывод данных воспринимался пользователями ЭВМ —
учёными-математиками — как нечто необходимое, но к работе ЭВМ имеющее лишь
косвенное отношение. Учёного было довольно просто обучить, чтобы он составлял
программы и оформлял входные данные для расчётов одним каким-нибудь способом,
например, при помощи перфокарт. Подключение к компьютеру какого-нибудь другого
устройства было делом трудоёмким, так как требовало усилий и электронщика, и
программиста. Да и нужно это было нечасто.

Нынешний компьютер — игрушка не учёного, а любого рядового обывателя. Это
бытовой прибор. Мало того, компьютер — это «самый умный» бытовой прибор:
если имеется какой-нибудь другой бытовой прибор (скажем, кофеварка),
прогрессивный обыватель тут же задумывается, нельзя ли обучить компьютер
управлять этим прибором (скажем, варить кофе за минуту до приезда хозяина). В
идеале получается «электронный дом», в котором работу любого оборудования можно
контролировать, не вставая из-за рабочего места, или даже не садясь за него —
посредством сети Интернет.

Самое поверхностное суждение об оборудовании и компьютере — что для подключения
прибора нужна волшебная субстанция по имени «драйвер». Есть драйвер — компьютер
оборудование «видит», нет драйвера — «не видит».

Это суждение во многом неверно.

=== Что такое «оборудование»? ===

Что и как можно подключить к компьютеру? Во-первых, на поверхности его корпуса
обычно наблюдается множество разнообразных отверстий и разъёмов, очевидно
предназначенных для того, чтобы туда что-то подключали. Уже подключены:
клавиатура, мышь, монитор, возможно — принтер, наушники или колонки. Много
отверстий остаётся неиспользованными, но и аппаратуры в «электронном доме» ещё
много — от КПК до той же кофеварки (если на ней есть соответствующий разъём).

Во-вторых, внутри компьютера имеются специальные разъёмы для подключения к ним
*плат расширения*: устройств, выглядящих не как бытовой прибор, а скорее как
деталь самого компьютера. Таковы видеоадаптеры, сетевые адаптеры, «внутренние»
модемы и т. п. Эти устройства — главный источник «Саги о Драйверах», потому что
их много, и создатели каждого такого устройства желают сохранить его устройство
втайне от конкурентов, прилагая к ним вместо документации ту самую волшебную субстанцию
с пометкой «нажмите кнопку «Пуск» и попытайтесь расслабиться: от вас уже ничего
не зависит».

В-третьих, ещё более внутри компьютера есть какие-то устройства, которые нельзя
ни отключить, ни подключить, однако они используются при работе, имеют какое-то
название и на разных компьютерах могут весьма отличаться. Например, звуковые
подсистемы могут быть интегрированными, а могут быть выполненными в виде платы
расширения, отличаясь редкостным разнообразием моделей и однообразием функций
(разъём для микрофона, разъём (ы) для колонок, линейный вход... что-то ещё?).
Или устройство, к которому подключаются жёсткие диски: оно может быть рассчитано
на 1 диск, 2, 4, иногда — более, иметь разные дополнительные свойства... и тоже
требовать «драйвера» — по крайней мере, поддержки со стороны системы.

Что точно отличает один прибор от другого — это внешний вид разъёма, с помощью
которого они подключаются к компьютеру. Очевидно, приборами, подключаемыми к
разъёмам разного типа, машина управляет существенно по-разному. Более того,
разъёмы настолько различны, что соединительный кабель одного типа просто не
влезет в разъём другого1. Но всё равно, это не решает проблемы идентификации:
например, мышь, подключённая к разъёму (порту) USB, отлично работает, а с
цифровой фотокамерой как-то спроста не получается. Опять «драйвер» нужен?

Можно добавить, что некоторое оборудование вообще не нуждается в том, чтобы
машине объявляли о его существовании: так, что бы ни подключалось к аналоговому
звуковому входу, работать оно будет одинаково, компьютер не отличит колонки от
наушников, да и отсутствия их не заметит. Словом, наружное наблюдение не даёт
достаточно информации о том, как работать с оборудованием. На помощь должна
прийти документация, но если в ней опять встретится слово «драйвер», оно может
означать что угодно: слишком оно неопределённое.

=== Как распознаётся оборудование? ===

Попробуем внести определённость. Какую информацию относительно подключаемого
прибора получает компьютер, и как он её получает?

Очевидно, «с той стороны», каждого разъёма, (допустим, USB, в который мы
воткнули flash-диск), имеется какое-то оборудование, которое позволяет им
пользоваться (как и USB-мышкой, USB-принтером и т. п). Это оборудование:

- определяет тип подключённого устройства
- управляет им (может, например, выключить или включить)
- передаёт на это устройство данные и/или принимает их оттуда

Такое оборудование называется *шиной* (bus). Этимология этого слова — что
русского, что английского — загадочна и восходит к доисторическим временам,
когда компьютеры назывались «ЭВМ».

Шин в компьютере несколько (грубо говоря — по количеству различных типов
разъёмов). Есть совсем «глупые» шины — например, порт последовательного
ввода-вывода (к нему подключаются мыши и прочая аппаратура «старого образца»).
Глупость их в том, что информацию о типе подключённого оборудования приходится
задавать вручную — либо заранее, либо с помощью наводящих вопросов пользователю.

Есть шины весьма умные, способные опросить и понять множество характеристик
подключённого устройства. Такова, например, шина PCI — наиболее распространённое
на сегодня оборудование для подключения плат расширения. Любопытный пользователь
может посмотреть список устройств, подключённых к шине PCI с помощью команды
`lspci` (от «list PCI», команда из пакета pciutils):

----------------------------------------------------------------
[tmpuser@arnor tmpuser]$ lspci

0000:00:00.0 Host bridge: VIA Technologies, Inc. VT8377 [KT400/KT600 AGP] Host Bridge (rev 80)
0000:00:01.0 PCI bridge: VIA Technologies, Inc. VT8237 PCI Bridge
0000:00:0f.0 RAID bus controller: VIA Technologies, Inc. VIA VT6420 SATA RAID Controller (rev 80)
0000:00:0f.1 IDE interface: VIA Technologies, Inc. VT82C586A/B/VT82C686/A/B/VT823x/A/C PIPC Bus Master IDE (rev 06)
0000:00:10.0 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller (rev 81)
0000:00:10.1 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller (rev 81)
0000:00:10.2 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller (rev 81)
0000:00:10.3 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller (rev 81)
0000:00:10.4 USB Controller: VIA Technologies, Inc. USB 2.0 (rev 86)
0000:00:11.0 ISA bridge: VIA Technologies, Inc. VT8237 ISA bridge [KT600/K8T800/K8T890 South]
0000:00:11.5 Multimedia audio controller: VIA Technologies, Inc. VT8233/A/8235/8237 AC97 Audio Controller (rev 60)
0000:00:12.0 Ethernet controller: VIA Technologies, Inc. VT6102 [Rhine-II] (rev 78)
0000:01:00.0 VGA compatible controller: ATI Technologies Inc Radeon R100 QD [Radeon 7200]
----------------------------------------------------------------

Из устройств на иллюстрации только одно — видеокарта Radeon 72002 — в
действительности является платой расширения, все остальные интегрированы в
системную плату (бывает и по-другому). Тип устройства — «Multimedia audio
controller», «Ethernet controller», «VGA compatible controller» и т. п.
— лишь небольшая часть информации, которую шине рассказали о себе подключённые
к ней устройства.

К шине PCI в качестве устройства подключена другая шина — USB, служащая для
подсоединения внешних устройств. Она тоже довольно умная, а ещё отличается тем,
что устройства подключаются к ней и отключаются от неё довольно часто. Существует
команда `lsusb` (из пакета, естественно, usbutils), но ей, как и `lspci`
приходится пользоваться нечасто (она даже убрана в каталог /usr/sbin, с глаз
пользовательских долой):

---------------------------------------
[tmpuser@arnor tmpuser]$ /usr/sbin/lsusb    
Bus 005 Device 001: ID 0000:0000  
Bus 004 Device 001: ID 0000:0000  
Bus 003 Device 001: ID 0000:0000  
Bus 002 Device 002: ID 046d:c00c Logitech, Inc. Optical Wheel Mouse
Bus 002 Device 001: ID 0000:0000  
Bus 001 Device 003: ID 08ec:0012 M-Systems Flash Disk Pioneers 
Bus 001 Device 001: ID 0000:0000  
---------------------------------------

Пример показывает пять USB-шин (это совпадает с данными `lspci`), к первой из
которых подключён flash-диск, а ко второй — мышь3. Как правило, устройство
определяется шиной, после чего специально обученная системная программа
производит все действия, необходимые для того, чтобы этим устройством можно
было воспользоваться. Например, для flash-диска потребовалось дополнительно
загрузить модуль ядра usb_storage, да вдобавок смонтировать содержимое диска
в каталог /media/usbdisk.

Специальный каталог /sys отражает представление системы о присоединённых к ней
устройствах. В частности, все найденные на шинах устройства перечислены в виде
подкаталогов /sys/bus/шина/devices. Если устройство установлено, а умная шина,
наподобие PCI или USB, его не заметила — скорее всего неполадка аппаратная
(несовместимое или неисправное устройство, таракан в разъёме и т. п.).

Увы. Бывает и так: устройство (видеокарта, модем, кофеварка) на шине появилось,
а воспользоваться им не удаётся. Видимо, чего-то не хватает... драйвера?

=== Что такое «драйвер» и где он находится? ===

А в самом деле, чего может не хватать, если устройство распозналось, марка
устройства — известна и как передавать данные по шине — тоже известно? Не
хватает главного: сведений о том, какие данные надо передавать, чтобы добиться
от устройства желаемого эффекта. Что передать по шине USB, чтобы кофеварка
выключилась? Какие байты записать в последовательный порт модема, чтобы он
повесил трубку? Что сделать с видеокартой, чтобы... всё было быстро и
непременно 3d!?

Это вот «какие данные» — и есть «драйвер». Драйвер может быть где угодно, на
любом уровне системы: от модуля ядра до куска пользовательской программы и
даже её конфигурационного файла. Типичные варианты:

Драйвер — *модуль ядра*, подсказывающий шине, как правильно обращаться с
устройством. Это, как правило, относится к PCI-устройствам и стандартным
USB-устройствам. Подключается к ядру командой `modprobe` имя_модуля
(или `insmod`). Распознанные и классифицированные устройства (те,
для которых есть драйвер-модуль ядра) отображаются в виде подкаталогов
/sys/class/класс_устройства/.

Драйвер видеокарты — модуль графической подсистемы X11 (X.Org). Подгружается
при старте графической оболочки, достаточно лишь указать его в настройках X.Org
(с помощью конфигуратора или вручную, в файле /etc/X11/xorg.conf). Часто
требуется и специальный модуль ядра (возможно, несколько), организующий доступ
к видеопамяти.

Драйверы принтера и модема — описание характеристик для, соответственно,
подсистемы печати и программы-«звонилки». Что с ними делать дальше,
расскажет документация.

Драйвер — прикладная программа или дополнение (plug-in) к ней (например,
драйвер сканера — дополнение утилиты sane, а с некоторыми цифровыми
проигрывателями звука «iRiver» можно взаимодействовать с помощью утилиты
`ifp` из пакета ifp-line). Здесь главное — название программы, а драйвер,
скорее всего, уже включён в дистрибутив.

В последнем случае нет никакой зримой информации о том, что устройством действительно
можно пользоваться — до тех пор, пока не запущена соответствующая прикладная
программа с соответствующими настройками (особенно это касается «глупых» шин
наподобие последовательного порта). И в любом случае самостоятельная установка
«драйвера» должна сопровождаться вдумчивым чтением документации к нему.

=== Опять «устройство»? ===

В документации Linux термин «устройство» (device) часто используется не в
значении «прибор», а в значении «элемент каталога /dev». Что это такое?

Прибор подключается к машине, как правило, для того, чтобы передавать на него
какие-то данные и/или получать их оттуда. Если задача компьютера — управлять
внешним устройством, это всё равно можно рассматривать как передачу управляющих
данных и приём диагностических. Во многих случаях передачу данных проще всего
вести в синхронном (поточном) режиме, точно так же, как это делается при работе
с файлом: открыть файл — записать данные — закрыть файл или открыть — прочитать
— закрыть. Если бы можно было представить внутренность прибора в виде файла,
работа с ним пошла бы легче: это означало бы, что система знает, как и куда
передавать данные, а дело пользовательской программы — эти данные понимать4.

В большинстве случаев именно так и устроено в Linux. После того, как система
распознала внешнее устройство, а служба hotplug, при необходимости, загрузила
соответствующий модуль ядра, в каталоге /dev заводится новый «файл», содержимое
которого отражает содержимое подключённого устройства, не занимая при этом места
на жёстком диске. Такой файл называется файлом-дыркой, его можно представить как
отверстие в файловой системе, через которое видно не содержимое жёсткого диска,
а данные, попадающие туда с «другой стороны» — со стороны подключённого внешнего
устройства. Например, гибкий диск в дисководе представляется в виде файла-дырки
/dev/fd0, (от floppy disk 0), а мышь — в виде /dev/mouse (строго говоря
/dev/mouse — этот обычно символьная ссылка на актуальный файл-дырку — скажем
/dev/psaux, порт PS/2).

В документации вместо «файл-дырка» чаще всего пишут просто «устройство»
(device), а устройство-прибор — «внешним устройством». Если соответствующего
устройства в каталоге /dev/ нет — значит, в цепочке его распознавания есть
слабое звено.

Стоит напомнить, что файл-дырка, однако, не обязан существовать и непременно
соответствовать одному внешнему устройству. Устройства, подключаемые ко второму
последовательному порту, например, всегда видны как /dev/ttyS1 (а к первому —
как ttyS0). Фактически, ttyS — это файл-дырка шины, настолько простой, что
дальнейшее выяснение типа устройства перекладывается на программу пользователя.

Другой пример — это работа с аппаратурой по шине USB. USB-шин в системе
зарегистрировано несколько, и к каждому можно подключить одно или несколько
устройств. Для них независимо от типа устройства заводятся файлы-дырки вида
usbdev.шина.номер, где каждому новому подключённому устройству просто выдаётся
очередной номер. Некоторые звуковые проигрыватели и цифровые фотокамеры
распознаются как flash-диски; тогда в дополнение к нетипизированному
файлу-дырке создаётся одна или даже несколько дисковых (допустим, само дисковое
устройство /dev/sda и единственный раздел с файловой системой на нём /dev/sda1,
который и монтируется в /media/usbdisk). Другие фотокамеры умеют больше, чем
обычный диск: например, транслировать изображение и/или звук, и для них
существуют специальные утилиты, например, gphoto2. В этом случае никакого
дополнительного файла-дырки, за исключением /dev/usbdev.шина.номер, не создаётся,
и о типе подключённого аппарата догадывается сама gphoto2.

=== Кто виноват и что делать? ===

Итак, свежеподключённый к компьютеру прибор не распознался «сам собой»,
и программы, которые должны были с ним работать, не работают.

- Для начала стоит посмотреть на системную консоль (клавиши Ctrl + Alt + F12)
  и в файл /var/log/messages, возможно, системная диагностика подскажет, в чём дело
- Неполадки могут быть аппаратными (проверяется в /sys/bus или с помощью lspci,
  как сказано выше).
- Hotplug или другая программа автораспознавания может не знать про конкретный
  подключённый прибор (придётся в режиме суперпользователя вручную загрузить
  модуль с помощью modprobe, а чтобы не делать этого каждый раз —
  отредактировать /etc/modules.conf).
- Возможно, внешнее устройство распозналось и модуль для него есть, но служба
  udevd, которая заводит файлы-дырки в /dev, выбрала другое название или вовсе
  не завела нужного устройства (надо проанализировать содержимое /dev и,
  возможно, настроить udev или саму прикладную программу).
- Ваше устройство может быть слишком новым, а дистрибутив Linux — оказаться
  слишком старым. В этом случае рекомендуется обновить части системы,
  содержащие «драйвер» (в зависимости от ситуации — модуль ядра, само ядро,
  графическую оболочку или её библиотеку, прикладную программу, и т. п.).
- Стоит проверить, что сказано о вашем устройстве в сетевых информационных
  ресурсах (здесь поможет `lspci` или подобные ей утилиты, а
  также http://www.google.com). Вполне вероятно, там посоветуют загрузить
  некий заранее собранный модуль ядра (назовут его, конечно, «драйвером»)
  либо подскажут, какую именно программу следует использовать.
- Наконец, ваше устройство может просто не поддерживаться. Печально, но факт:
  некоторые производители аппаратуры настолько дорожат своими мелкими
  секретами, что не только не документируют устройство своих устройств, но
  тщательно скрывают его. Как следствие, Linux-сообщество не в состоянии быстро
  обеспечить поддержку таинственного прибора. Производители предпочитают писать
  «драйверы» — хорошие ли, плохие — за свои деньги, а особо жадные
  ограничиваются только одной, самой распространённой на сегодня
  пользовательской программной платформой. И это пока, к сожалению, не Linux.

Сказанное выше означает, что после каждого обновления системы устройство,
ранее распознававшееся с трудом или вовсе не распознававшееся, может7
преспокойно заработать, особенно если это устройство относительно новое.
Кроме того, стоит со всем вниманием относиться к ситуации, когда производитель
прибора не просто анонсирует совместимость с Linux, а предлагает «драйверы»
собственного изготовления. И последнее: если вы не в силах справиться с
«драйвером» в одиночку — обращайтесь к Linux-сообществу! Вы или получите
решение задачи, или в очередной раз подтвердите, что её стоит решать —
и тем самым приблизите решение.
